// SPDX-License-Identifier: MIT

import "./abstract/ReaperBaseStrategy.sol";
import "./interfaces/IUniswapRouter.sol";
import "./interfaces/IPaymentRouter.sol";
import "./interfaces/IFlashLoanRecipient.sol";
import "./interfaces/IFlashLoans.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

pragma solidity 0.8.9;

/**
 * @dev This is a strategy to stake Boo into xBoo, and then stake xBoo in different pools to collect more rewards
 * The strategy will compound the pool rewards into Boo which will be deposited into the strategy for more yield.
 */
contract ReaperAutoCompoundScreamFlashloan is ReaperBaseStrategy, IFlashLoanRecipient {
    using SafeERC20 for IERC20;

    /**
     * @dev Tokens Used:
     * {WFTM} - Required for liquidity routing when doing swaps. Also used to charge fees on yield.
     * {xBoo} - Token generated by staking our funds. Also used to stake in secondary pools.
     * {XTAROT} - Token that the strategy maximizes.
     */
    address public constant WFTM =
        address(0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83);
    IERC20 public constant TAROT =
        IERC20(0xC5e2B037D30a390e62180970B3aa4E91868764cD);

    /**
     * @dev Third Party Contracts:
     * {UNI_ROUTER} - the UNI_ROUTER for target DEX
     * {POOL_CONTROLLER} - Address to XStakingPoolController, the SpookySwap contract to stake xBoo
     */
    address public constant UNI_ROUTER =
        0xF491e7B69E4244ad4002BC14e878a34207E38c29;
    address public constant POOL_CONTROLLER =
        0x466eBD9EC2027776fa11a982E9BBe4F67aa6e86B;
    address public constant BEETHOVEN_VAULT = 0x20dd72Ed959b6147912C2e529F0a0C651c33c9ce;

    /**
     * @dev Routes we take to swap tokens
     * {wftmToBooRoute} - Route we take to get from {WFTM} into {XTAROT}.
     * {poolRewardToWftmPaths} - Routes for each pool to get from {pool reward token} into {WFTM}.
     */
    address[] public wftmToTarotRoute = [WFTM, address(TAROT)];
    mapping(uint256 => address[]) public poolRewardToWftmPaths;

    /**
     * @dev Variables for pool selection
     * {currentPoolId} - Pool id for the the current pool the strategy deposits xBoo into
     * {currentlyUsedPools} - A list of all pool ids currently being used by the strategy
     * {poolYield} - The estimated yield in WFTM for each pool over the next 1 day
     * {hasAllocatedToPool} - If a given pool id has been deposited into already for a harvest cycle
     * {WFTM_POOL_ID} - Id for the WFTM pool to use as default pool before pool selection
     * {maxPoolDilutionFactor} - The factor that determines what % of a pools total TVL can be deposited (to avoid dilution)
     * {maxNrOfPools} - The maximum amount of pools the strategy can use
     */
    uint256 public currentPoolId;
    uint256[] public currentlyUsedPools;
    mapping(uint256 => uint256) public poolYield;
    mapping(uint256 => bool) public hasAllocatedToPool;
    uint256 public maxPoolDilutionFactor = 5;
    uint256 public maxNrOfPools = 15;

    /**
     * @dev Variables for pool selection
     * {totalPoolBalance} - The total amount of xBoo currently deposited into pools
     * {poolxTarotBalance} - The amount of xBoo deposited into each pool
     */
    uint256 public totalPoolBalance = 0;
    mapping(uint256 => uint256) public poolxTarotBalance;

    /**
     * {UpdatedStrategist} Event that is fired each time the strategist role is updated.
     */
    event UpdatedStrategist(address newStrategist);

    /**
     * @dev Initializes the strategy. Sets parameters, saves routes, and gives allowances.
     * @notice see documentation for each variable above its respective declaration.
     */
    constructor(
        address _vault,
        address[] memory _feeRemitters,
        address[] memory _strategists
    ) ReaperBaseStrategy(_vault, _feeRemitters, _strategists) {
        _giveAllowances();
    }

    function receiveFlashLoan(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory userData
    ) external {
        // Do stuff
    }

    function testFlashLoan() external {
        IERC20[] memory tokens = new IERC20[](1);
        uint256[] memory amounts = new uint256[](1);
        bytes memory userData;

        tokens[0] = IERC20(WFTM);
        uint256 borrowAmount = 100000;
        amounts[0] = borrowAmount;

        IFlashLoans(BEETHOVEN_VAULT).flashLoan(this, tokens, amounts, userData);
    }

    /**
     * @dev Function that puts the funds to work.
     * It gets called whenever someone deposits in the strategy's vault contract.
     * It deposits {XTAROT} into xBoo (BooMirrorWorld) to farm {xBoo} and finally,
     * xBoo is deposited into other pools to earn additional rewards
     */
    function deposit() public whenNotPaused {
        
    }

    /**
     * @dev Withdraws funds and sents them back to the vault.
     * It withdraws {XTAROT} from the XStakingPoolController pools.
     * The available {XTAROT} minus fees is returned to the vault.
     */
    function withdraw(uint256 _amount) external {
    }

    /**
     * @dev Core function of the strat, in charge of collecting and re-investing rewards.
     * 1. It claims rewards from the XStakingPoolController pools and estimated the current yield for each pool.
     * 2. It charges the system fees to simplify the split.
     * 3. It swaps the {WFTM} token for {Boo} which is deposited into {xBoo}
     * 4. It distributes the xBoo using a yield optimization algorithm into various pools.
     */
    function _harvestCore() internal override {
    }

    /**
     * @dev Returns the approx amount of profit from harvesting.
     *      Profit is denominated in WFTM, and takes fees into account.
     */
    function estimateHarvest()
        external
        view
        override
        returns (uint256 profit, uint256 callFeeToUser)
    {
    }

    /**
     * @dev Function to calculate the total underlaying {XTAROT} held by the strat.
     * It takes into account both the funds in hand, as the funds allocated in xBoo and the XStakingPoolController pools.
     */
    function balanceOf() public view override returns (uint256) {
        return 0;
    }

    /**
     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the
     * vault, ready to be migrated to the new strat.
     */
    function retireStrat() external {
    }

    /**
     * @dev Pauses deposits. Withdraws all funds from the AceLab contract, leaving rewards behind.
     */
    function panic() public {
        _onlyStrategistOrOwner();
        pause();
    }

    /**
     * @dev Pauses the strat.
     */
    function pause() public {
        _onlyStrategistOrOwner();
        _pause();
        _removeAllowances();
    }

    /**
     * @dev Unpauses the strat.
     */
    function unpause() external {
        _onlyStrategistOrOwner();
        _unpause();

        _giveAllowances();

        deposit();
    }

    /**
     * @dev Gives max allowance of {XTAROT} for the {xBoo} contract,
     * {xBoo} allowance for the {POOL_CONTROLLER} contract,
     * {WFTM} allowance for the {UNI_ROUTER}
     * in addition to allowance to all pool rewards for the {UNI_ROUTER}.
     */
    function _giveAllowances() internal {
    }

    /**
     * @dev Removes all allowance of {stakingToken} for the {xToken} contract,
     * {xToken} allowance for the {aceLab} contract,
     * {wftm} allowance for the {uniRouter}
     * in addition to allowance to all pool rewards for the {uniRouter}.
     */
    function _removeAllowances() internal {
    }
}
